// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: admin.proto

package admin

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NodeGroupClient is the client API for NodeGroup service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeGroupClient interface {
	InsertNodeGroup(ctx context.Context, in *NodeGroupReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateNodeGroup(ctx context.Context, in *NodeGroupReq, opts ...grpc.CallOption) (*AffectedResp, error)
	RemoveNodeGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error)
	GetNodeGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NodeGroupUnit, error)
	GetNodeGroupList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeGroupList, error)
}

type nodeGroupClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeGroupClient(cc grpc.ClientConnInterface) NodeGroupClient {
	return &nodeGroupClient{cc}
}

func (c *nodeGroupClient) InsertNodeGroup(ctx context.Context, in *NodeGroupReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.NodeGroup/insertNodeGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupClient) UpdateNodeGroup(ctx context.Context, in *NodeGroupReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.NodeGroup/updateNodeGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupClient) RemoveNodeGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.NodeGroup/removeNodeGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupClient) GetNodeGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NodeGroupUnit, error) {
	out := new(NodeGroupUnit)
	err := c.cc.Invoke(ctx, "/bodhi.NodeGroup/getNodeGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupClient) GetNodeGroupList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeGroupList, error) {
	out := new(NodeGroupList)
	err := c.cc.Invoke(ctx, "/bodhi.NodeGroup/getNodeGroupList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeGroupServer is the server API for NodeGroup service.
// All implementations must embed UnimplementedNodeGroupServer
// for forward compatibility
type NodeGroupServer interface {
	InsertNodeGroup(context.Context, *NodeGroupReq) (*AffectedResp, error)
	UpdateNodeGroup(context.Context, *NodeGroupReq) (*AffectedResp, error)
	RemoveNodeGroup(context.Context, *Id) (*AffectedResp, error)
	GetNodeGroup(context.Context, *Id) (*NodeGroupUnit, error)
	GetNodeGroupList(context.Context, *Empty) (*NodeGroupList, error)
	mustEmbedUnimplementedNodeGroupServer()
}

// UnimplementedNodeGroupServer must be embedded to have forward compatible implementations.
type UnimplementedNodeGroupServer struct {
}

func (UnimplementedNodeGroupServer) InsertNodeGroup(context.Context, *NodeGroupReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertNodeGroup not implemented")
}
func (UnimplementedNodeGroupServer) UpdateNodeGroup(context.Context, *NodeGroupReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeGroup not implemented")
}
func (UnimplementedNodeGroupServer) RemoveNodeGroup(context.Context, *Id) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNodeGroup not implemented")
}
func (UnimplementedNodeGroupServer) GetNodeGroup(context.Context, *Id) (*NodeGroupUnit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeGroup not implemented")
}
func (UnimplementedNodeGroupServer) GetNodeGroupList(context.Context, *Empty) (*NodeGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeGroupList not implemented")
}
func (UnimplementedNodeGroupServer) mustEmbedUnimplementedNodeGroupServer() {}

// UnsafeNodeGroupServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeGroupServer will
// result in compilation errors.
type UnsafeNodeGroupServer interface {
	mustEmbedUnimplementedNodeGroupServer()
}

func RegisterNodeGroupServer(s grpc.ServiceRegistrar, srv NodeGroupServer) {
	s.RegisterService(&NodeGroup_ServiceDesc, srv)
}

func _NodeGroup_InsertNodeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServer).InsertNodeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.NodeGroup/insertNodeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServer).InsertNodeGroup(ctx, req.(*NodeGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroup_UpdateNodeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServer).UpdateNodeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.NodeGroup/updateNodeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServer).UpdateNodeGroup(ctx, req.(*NodeGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroup_RemoveNodeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServer).RemoveNodeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.NodeGroup/removeNodeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServer).RemoveNodeGroup(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroup_GetNodeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServer).GetNodeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.NodeGroup/getNodeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServer).GetNodeGroup(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroup_GetNodeGroupList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServer).GetNodeGroupList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.NodeGroup/getNodeGroupList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServer).GetNodeGroupList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeGroup_ServiceDesc is the grpc.ServiceDesc for NodeGroup service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeGroup_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.NodeGroup",
	HandlerType: (*NodeGroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "insertNodeGroup",
			Handler:    _NodeGroup_InsertNodeGroup_Handler,
		},
		{
			MethodName: "updateNodeGroup",
			Handler:    _NodeGroup_UpdateNodeGroup_Handler,
		},
		{
			MethodName: "removeNodeGroup",
			Handler:    _NodeGroup_RemoveNodeGroup_Handler,
		},
		{
			MethodName: "getNodeGroup",
			Handler:    _NodeGroup_GetNodeGroup_Handler,
		},
		{
			MethodName: "getNodeGroupList",
			Handler:    _NodeGroup_GetNodeGroupList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeClient interface {
	InsertNode(ctx context.Context, in *NodeReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateNode(ctx context.Context, in *NodeReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateStatus(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error)
	RemoveNode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error)
	GetNode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NodeUnit, error)
	GetList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeListResp, error)
	GetNodeListByGid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NodeListResp, error)
	ListNode(ctx context.Context, in *PageReq, opts ...grpc.CallOption) (*ListNodeResp, error)
	BatchMove(ctx context.Context, in *MoveReq, opts ...grpc.CallOption) (*AffectedResp, error)
	BatchRemove(ctx context.Context, in *BatchIdsReq, opts ...grpc.CallOption) (*AffectedResp, error)
}

type nodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) InsertNode(ctx context.Context, in *NodeReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/insertNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) UpdateNode(ctx context.Context, in *NodeReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/updateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) UpdateStatus(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/updateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RemoveNode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/removeNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NodeUnit, error) {
	out := new(NodeUnit)
	err := c.cc.Invoke(ctx, "/bodhi.Node/getNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeListResp, error) {
	out := new(NodeListResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/getList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNodeListByGid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NodeListResp, error) {
	out := new(NodeListResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/getNodeListByGid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListNode(ctx context.Context, in *PageReq, opts ...grpc.CallOption) (*ListNodeResp, error) {
	out := new(ListNodeResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/listNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) BatchMove(ctx context.Context, in *MoveReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/batchMove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) BatchRemove(ctx context.Context, in *BatchIdsReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Node/batchRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
// All implementations must embed UnimplementedNodeServer
// for forward compatibility
type NodeServer interface {
	InsertNode(context.Context, *NodeReq) (*AffectedResp, error)
	UpdateNode(context.Context, *NodeReq) (*AffectedResp, error)
	UpdateStatus(context.Context, *Id) (*AffectedResp, error)
	RemoveNode(context.Context, *Id) (*AffectedResp, error)
	GetNode(context.Context, *Id) (*NodeUnit, error)
	GetList(context.Context, *Empty) (*NodeListResp, error)
	GetNodeListByGid(context.Context, *Id) (*NodeListResp, error)
	ListNode(context.Context, *PageReq) (*ListNodeResp, error)
	BatchMove(context.Context, *MoveReq) (*AffectedResp, error)
	BatchRemove(context.Context, *BatchIdsReq) (*AffectedResp, error)
	mustEmbedUnimplementedNodeServer()
}

// UnimplementedNodeServer must be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (UnimplementedNodeServer) InsertNode(context.Context, *NodeReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertNode not implemented")
}
func (UnimplementedNodeServer) UpdateNode(context.Context, *NodeReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}
func (UnimplementedNodeServer) UpdateStatus(context.Context, *Id) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedNodeServer) RemoveNode(context.Context, *Id) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNode not implemented")
}
func (UnimplementedNodeServer) GetNode(context.Context, *Id) (*NodeUnit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedNodeServer) GetList(context.Context, *Empty) (*NodeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetList not implemented")
}
func (UnimplementedNodeServer) GetNodeListByGid(context.Context, *Id) (*NodeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeListByGid not implemented")
}
func (UnimplementedNodeServer) ListNode(context.Context, *PageReq) (*ListNodeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNode not implemented")
}
func (UnimplementedNodeServer) BatchMove(context.Context, *MoveReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchMove not implemented")
}
func (UnimplementedNodeServer) BatchRemove(context.Context, *BatchIdsReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchRemove not implemented")
}
func (UnimplementedNodeServer) mustEmbedUnimplementedNodeServer() {}

// UnsafeNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServer will
// result in compilation errors.
type UnsafeNodeServer interface {
	mustEmbedUnimplementedNodeServer()
}

func RegisterNodeServer(s grpc.ServiceRegistrar, srv NodeServer) {
	s.RegisterService(&Node_ServiceDesc, srv)
}

func _Node_InsertNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).InsertNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/insertNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).InsertNode(ctx, req.(*NodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/updateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).UpdateNode(ctx, req.(*NodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/updateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).UpdateStatus(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RemoveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RemoveNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/removeNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RemoveNode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/getNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/getList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNodeListByGid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNodeListByGid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/getNodeListByGid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNodeListByGid(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/listNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListNode(ctx, req.(*PageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_BatchMove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).BatchMove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/batchMove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).BatchMove(ctx, req.(*MoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_BatchRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).BatchRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Node/batchRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).BatchRemove(ctx, req.(*BatchIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Node_ServiceDesc is the grpc.ServiceDesc for Node service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Node_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "insertNode",
			Handler:    _Node_InsertNode_Handler,
		},
		{
			MethodName: "updateNode",
			Handler:    _Node_UpdateNode_Handler,
		},
		{
			MethodName: "updateStatus",
			Handler:    _Node_UpdateStatus_Handler,
		},
		{
			MethodName: "removeNode",
			Handler:    _Node_RemoveNode_Handler,
		},
		{
			MethodName: "getNode",
			Handler:    _Node_GetNode_Handler,
		},
		{
			MethodName: "getList",
			Handler:    _Node_GetList_Handler,
		},
		{
			MethodName: "getNodeListByGid",
			Handler:    _Node_GetNodeListByGid_Handler,
		},
		{
			MethodName: "listNode",
			Handler:    _Node_ListNode_Handler,
		},
		{
			MethodName: "batchMove",
			Handler:    _Node_BatchMove_Handler,
		},
		{
			MethodName: "batchRemove",
			Handler:    _Node_BatchRemove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}

// MenuClient is the client API for Menu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuClient interface {
	InsertMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateStatus(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*AffectedResp, error)
	RemoveMenu(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error)
	GetMenu(ctx context.Context, in *Id, opts ...grpc.CallOption) (*MenuResp, error)
	GetMenuListByPid(ctx context.Context, in *ListMenuReq, opts ...grpc.CallOption) (*MenuListResp, error)
	GetMenuListByType(ctx context.Context, in *MenuTypeResp, opts ...grpc.CallOption) (*MenuListResp, error)
}

type menuClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuClient(cc grpc.ClientConnInterface) MenuClient {
	return &menuClient{cc}
}

func (c *menuClient) InsertMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/insertMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) UpdateMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/updateMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) UpdateStatus(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/updateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) RemoveMenu(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/removeMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenu(ctx context.Context, in *Id, opts ...grpc.CallOption) (*MenuResp, error) {
	out := new(MenuResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/getMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuListByPid(ctx context.Context, in *ListMenuReq, opts ...grpc.CallOption) (*MenuListResp, error) {
	out := new(MenuListResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/getMenuListByPid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuListByType(ctx context.Context, in *MenuTypeResp, opts ...grpc.CallOption) (*MenuListResp, error) {
	out := new(MenuListResp)
	err := c.cc.Invoke(ctx, "/bodhi.Menu/getMenuListByType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServer is the server API for Menu service.
// All implementations must embed UnimplementedMenuServer
// for forward compatibility
type MenuServer interface {
	InsertMenu(context.Context, *MenuReq) (*AffectedResp, error)
	UpdateMenu(context.Context, *MenuReq) (*AffectedResp, error)
	UpdateStatus(context.Context, *StatusReq) (*AffectedResp, error)
	RemoveMenu(context.Context, *Id) (*AffectedResp, error)
	GetMenu(context.Context, *Id) (*MenuResp, error)
	GetMenuListByPid(context.Context, *ListMenuReq) (*MenuListResp, error)
	GetMenuListByType(context.Context, *MenuTypeResp) (*MenuListResp, error)
	mustEmbedUnimplementedMenuServer()
}

// UnimplementedMenuServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServer struct {
}

func (UnimplementedMenuServer) InsertMenu(context.Context, *MenuReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertMenu not implemented")
}
func (UnimplementedMenuServer) UpdateMenu(context.Context, *MenuReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServer) UpdateStatus(context.Context, *StatusReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedMenuServer) RemoveMenu(context.Context, *Id) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMenu not implemented")
}
func (UnimplementedMenuServer) GetMenu(context.Context, *Id) (*MenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenu not implemented")
}
func (UnimplementedMenuServer) GetMenuListByPid(context.Context, *ListMenuReq) (*MenuListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuListByPid not implemented")
}
func (UnimplementedMenuServer) GetMenuListByType(context.Context, *MenuTypeResp) (*MenuListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuListByType not implemented")
}
func (UnimplementedMenuServer) mustEmbedUnimplementedMenuServer() {}

// UnsafeMenuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServer will
// result in compilation errors.
type UnsafeMenuServer interface {
	mustEmbedUnimplementedMenuServer()
}

func RegisterMenuServer(s grpc.ServiceRegistrar, srv MenuServer) {
	s.RegisterService(&Menu_ServiceDesc, srv)
}

func _Menu_InsertMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).InsertMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/insertMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).InsertMenu(ctx, req.(*MenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/updateMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).UpdateMenu(ctx, req.(*MenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/updateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).UpdateStatus(ctx, req.(*StatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_RemoveMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).RemoveMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/removeMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).RemoveMenu(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/getMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenu(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuListByPid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuListByPid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/getMenuListByPid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuListByPid(ctx, req.(*ListMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuListByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuTypeResp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuListByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Menu/getMenuListByType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuListByType(ctx, req.(*MenuTypeResp))
	}
	return interceptor(ctx, in, info, handler)
}

// Menu_ServiceDesc is the grpc.ServiceDesc for Menu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.Menu",
	HandlerType: (*MenuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "insertMenu",
			Handler:    _Menu_InsertMenu_Handler,
		},
		{
			MethodName: "updateMenu",
			Handler:    _Menu_UpdateMenu_Handler,
		},
		{
			MethodName: "updateStatus",
			Handler:    _Menu_UpdateStatus_Handler,
		},
		{
			MethodName: "removeMenu",
			Handler:    _Menu_RemoveMenu_Handler,
		},
		{
			MethodName: "getMenu",
			Handler:    _Menu_GetMenu_Handler,
		},
		{
			MethodName: "getMenuListByPid",
			Handler:    _Menu_GetMenuListByPid_Handler,
		},
		{
			MethodName: "getMenuListByType",
			Handler:    _Menu_GetMenuListByType_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleClient interface {
	InsertRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateStatus(ctx context.Context, in *UuidStatusReq, opts ...grpc.CallOption) (*AffectedResp, error)
	RemoveRole(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*AffectedResp, error)
	GetRole(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*RoleUnit, error)
	ListRole(ctx context.Context, in *PageReq, opts ...grpc.CallOption) (*ListRoleResp, error)
	GetList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RoleListResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) InsertRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Role/insertRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) UpdateRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Role/updateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) UpdateStatus(ctx context.Context, in *UuidStatusReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Role/updateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RemoveRole(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Role/removeRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GetRole(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*RoleUnit, error) {
	out := new(RoleUnit)
	err := c.cc.Invoke(ctx, "/bodhi.Role/getRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) ListRole(ctx context.Context, in *PageReq, opts ...grpc.CallOption) (*ListRoleResp, error) {
	out := new(ListRoleResp)
	err := c.cc.Invoke(ctx, "/bodhi.Role/listRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GetList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RoleListResp, error) {
	out := new(RoleListResp)
	err := c.cc.Invoke(ctx, "/bodhi.Role/getList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility
type RoleServer interface {
	InsertRole(context.Context, *RoleReq) (*AffectedResp, error)
	UpdateRole(context.Context, *RoleReq) (*AffectedResp, error)
	UpdateStatus(context.Context, *UuidStatusReq) (*AffectedResp, error)
	RemoveRole(context.Context, *Uuid) (*AffectedResp, error)
	GetRole(context.Context, *Uuid) (*RoleUnit, error)
	ListRole(context.Context, *PageReq) (*ListRoleResp, error)
	GetList(context.Context, *Empty) (*RoleListResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServer struct {
}

func (UnimplementedRoleServer) InsertRole(context.Context, *RoleReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertRole not implemented")
}
func (UnimplementedRoleServer) UpdateRole(context.Context, *RoleReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServer) UpdateStatus(context.Context, *UuidStatusReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedRoleServer) RemoveRole(context.Context, *Uuid) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRole not implemented")
}
func (UnimplementedRoleServer) GetRole(context.Context, *Uuid) (*RoleUnit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedRoleServer) ListRole(context.Context, *PageReq) (*ListRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRole not implemented")
}
func (UnimplementedRoleServer) GetList(context.Context, *Empty) (*RoleListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetList not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_InsertRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).InsertRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/insertRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).InsertRole(ctx, req.(*RoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/updateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).UpdateRole(ctx, req.(*RoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UuidStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/updateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).UpdateStatus(ctx, req.(*UuidStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RemoveRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RemoveRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/removeRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RemoveRole(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/getRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GetRole(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_ListRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).ListRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/listRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).ListRole(ctx, req.(*PageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Role/getList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GetList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "insertRole",
			Handler:    _Role_InsertRole_Handler,
		},
		{
			MethodName: "updateRole",
			Handler:    _Role_UpdateRole_Handler,
		},
		{
			MethodName: "updateStatus",
			Handler:    _Role_UpdateStatus_Handler,
		},
		{
			MethodName: "removeRole",
			Handler:    _Role_RemoveRole_Handler,
		},
		{
			MethodName: "getRole",
			Handler:    _Role_GetRole_Handler,
		},
		{
			MethodName: "listRole",
			Handler:    _Role_ListRole_Handler,
		},
		{
			MethodName: "getList",
			Handler:    _Role_GetList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}

// AccountClient is the client API for Account service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountClient interface {
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error)
	Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*AffectedResp, error)
	RefreshToken(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*TokenResp, error)
	SetPassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*AffectedResp, error)
	GetPermission(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*PermissionResp, error)
}

type accountClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountClient(cc grpc.ClientConnInterface) AccountClient {
	return &accountClient{cc}
}

func (c *accountClient) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, "/bodhi.Account/login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Account/register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) RefreshToken(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*TokenResp, error) {
	out := new(TokenResp)
	err := c.cc.Invoke(ctx, "/bodhi.Account/refreshToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) SetPassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.Account/setPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) GetPermission(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*PermissionResp, error) {
	out := new(PermissionResp)
	err := c.cc.Invoke(ctx, "/bodhi.Account/getPermission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountServer is the server API for Account service.
// All implementations must embed UnimplementedAccountServer
// for forward compatibility
type AccountServer interface {
	Login(context.Context, *LoginReq) (*LoginResp, error)
	Register(context.Context, *RegisterReq) (*AffectedResp, error)
	RefreshToken(context.Context, *TokenReq) (*TokenResp, error)
	SetPassword(context.Context, *PasswordReq) (*AffectedResp, error)
	GetPermission(context.Context, *Uuid) (*PermissionResp, error)
	mustEmbedUnimplementedAccountServer()
}

// UnimplementedAccountServer must be embedded to have forward compatible implementations.
type UnimplementedAccountServer struct {
}

func (UnimplementedAccountServer) Login(context.Context, *LoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAccountServer) Register(context.Context, *RegisterReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAccountServer) RefreshToken(context.Context, *TokenReq) (*TokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAccountServer) SetPassword(context.Context, *PasswordReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPassword not implemented")
}
func (UnimplementedAccountServer) GetPermission(context.Context, *Uuid) (*PermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermission not implemented")
}
func (UnimplementedAccountServer) mustEmbedUnimplementedAccountServer() {}

// UnsafeAccountServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountServer will
// result in compilation errors.
type UnsafeAccountServer interface {
	mustEmbedUnimplementedAccountServer()
}

func RegisterAccountServer(s grpc.ServiceRegistrar, srv AccountServer) {
	s.RegisterService(&Account_ServiceDesc, srv)
}

func _Account_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Account/login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Account/register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Register(ctx, req.(*RegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Account/refreshToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).RefreshToken(ctx, req.(*TokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_SetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).SetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Account/setPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).SetPassword(ctx, req.(*PasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_GetPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).GetPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.Account/getPermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).GetPermission(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

// Account_ServiceDesc is the grpc.ServiceDesc for Account service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Account_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.Account",
	HandlerType: (*AccountServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "login",
			Handler:    _Account_Login_Handler,
		},
		{
			MethodName: "register",
			Handler:    _Account_Register_Handler,
		},
		{
			MethodName: "refreshToken",
			Handler:    _Account_RefreshToken_Handler,
		},
		{
			MethodName: "setPassword",
			Handler:    _Account_SetPassword_Handler,
		},
		{
			MethodName: "getPermission",
			Handler:    _Account_GetPermission_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	InsertUser(ctx context.Context, in *NewUserReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateUser(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateStatus(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdatePassword(ctx context.Context, in *UserPasswordReq, opts ...grpc.CallOption) (*AffectedResp, error)
	RemoveUser(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*AffectedResp, error)
	GetUser(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*UserUnit, error)
	ListUser(ctx context.Context, in *PageReq, opts ...grpc.CallOption) (*ListUserResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) InsertUser(ctx context.Context, in *NewUserReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.User/insertUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUser(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.User/updateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateStatus(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.User/updateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdatePassword(ctx context.Context, in *UserPasswordReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.User/updatePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) RemoveUser(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.User/removeUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUser(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*UserUnit, error) {
	out := new(UserUnit)
	err := c.cc.Invoke(ctx, "/bodhi.User/getUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ListUser(ctx context.Context, in *PageReq, opts ...grpc.CallOption) (*ListUserResp, error) {
	out := new(ListUserResp)
	err := c.cc.Invoke(ctx, "/bodhi.User/listUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	InsertUser(context.Context, *NewUserReq) (*AffectedResp, error)
	UpdateUser(context.Context, *UserReq) (*AffectedResp, error)
	UpdateStatus(context.Context, *Uuid) (*AffectedResp, error)
	UpdatePassword(context.Context, *UserPasswordReq) (*AffectedResp, error)
	RemoveUser(context.Context, *Uuid) (*AffectedResp, error)
	GetUser(context.Context, *Uuid) (*UserUnit, error)
	ListUser(context.Context, *PageReq) (*ListUserResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) InsertUser(context.Context, *NewUserReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertUser not implemented")
}
func (UnimplementedUserServer) UpdateUser(context.Context, *UserReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServer) UpdateStatus(context.Context, *Uuid) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedUserServer) UpdatePassword(context.Context, *UserPasswordReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePassword not implemented")
}
func (UnimplementedUserServer) RemoveUser(context.Context, *Uuid) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUser not implemented")
}
func (UnimplementedUserServer) GetUser(context.Context, *Uuid) (*UserUnit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServer) ListUser(context.Context, *PageReq) (*ListUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUser not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_InsertUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).InsertUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/insertUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).InsertUser(ctx, req.(*NewUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/updateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUser(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/updateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateStatus(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/updatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdatePassword(ctx, req.(*UserPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_RemoveUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).RemoveUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/removeUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).RemoveUser(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/getUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUser(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ListUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ListUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.User/listUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ListUser(ctx, req.(*PageReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "insertUser",
			Handler:    _User_InsertUser_Handler,
		},
		{
			MethodName: "updateUser",
			Handler:    _User_UpdateUser_Handler,
		},
		{
			MethodName: "updateStatus",
			Handler:    _User_UpdateStatus_Handler,
		},
		{
			MethodName: "updatePassword",
			Handler:    _User_UpdatePassword_Handler,
		},
		{
			MethodName: "removeUser",
			Handler:    _User_RemoveUser_Handler,
		},
		{
			MethodName: "getUser",
			Handler:    _User_GetUser_Handler,
		},
		{
			MethodName: "listUser",
			Handler:    _User_ListUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}

// UserRoleClient is the client API for UserRole service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserRoleClient interface {
	InsertUserRole(ctx context.Context, in *UserRoleReq, opts ...grpc.CallOption) (*AffectedResp, error)
	UpdateUserRole(ctx context.Context, in *UpdateUserRoleReq, opts ...grpc.CallOption) (*AffectedResp, error)
	RemoveUserRole(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error)
	GetUserRoles(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*UserRoleListResp, error)
}

type userRoleClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRoleClient(cc grpc.ClientConnInterface) UserRoleClient {
	return &userRoleClient{cc}
}

func (c *userRoleClient) InsertUserRole(ctx context.Context, in *UserRoleReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.UserRole/insertUserRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleClient) UpdateUserRole(ctx context.Context, in *UpdateUserRoleReq, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.UserRole/updateUserRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleClient) RemoveUserRole(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AffectedResp, error) {
	out := new(AffectedResp)
	err := c.cc.Invoke(ctx, "/bodhi.UserRole/removeUserRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleClient) GetUserRoles(ctx context.Context, in *Uuid, opts ...grpc.CallOption) (*UserRoleListResp, error) {
	out := new(UserRoleListResp)
	err := c.cc.Invoke(ctx, "/bodhi.UserRole/getUserRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRoleServer is the server API for UserRole service.
// All implementations must embed UnimplementedUserRoleServer
// for forward compatibility
type UserRoleServer interface {
	InsertUserRole(context.Context, *UserRoleReq) (*AffectedResp, error)
	UpdateUserRole(context.Context, *UpdateUserRoleReq) (*AffectedResp, error)
	RemoveUserRole(context.Context, *Id) (*AffectedResp, error)
	GetUserRoles(context.Context, *Uuid) (*UserRoleListResp, error)
	mustEmbedUnimplementedUserRoleServer()
}

// UnimplementedUserRoleServer must be embedded to have forward compatible implementations.
type UnimplementedUserRoleServer struct {
}

func (UnimplementedUserRoleServer) InsertUserRole(context.Context, *UserRoleReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertUserRole not implemented")
}
func (UnimplementedUserRoleServer) UpdateUserRole(context.Context, *UpdateUserRoleReq) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserRole not implemented")
}
func (UnimplementedUserRoleServer) RemoveUserRole(context.Context, *Id) (*AffectedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserRole not implemented")
}
func (UnimplementedUserRoleServer) GetUserRoles(context.Context, *Uuid) (*UserRoleListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRoles not implemented")
}
func (UnimplementedUserRoleServer) mustEmbedUnimplementedUserRoleServer() {}

// UnsafeUserRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRoleServer will
// result in compilation errors.
type UnsafeUserRoleServer interface {
	mustEmbedUnimplementedUserRoleServer()
}

func RegisterUserRoleServer(s grpc.ServiceRegistrar, srv UserRoleServer) {
	s.RegisterService(&UserRole_ServiceDesc, srv)
}

func _UserRole_InsertUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServer).InsertUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.UserRole/insertUserRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServer).InsertUserRole(ctx, req.(*UserRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRole_UpdateUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServer).UpdateUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.UserRole/updateUserRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServer).UpdateUserRole(ctx, req.(*UpdateUserRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRole_RemoveUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServer).RemoveUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.UserRole/removeUserRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServer).RemoveUserRole(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRole_GetUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServer).GetUserRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bodhi.UserRole/getUserRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServer).GetUserRoles(ctx, req.(*Uuid))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRole_ServiceDesc is the grpc.ServiceDesc for UserRole service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRole_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bodhi.UserRole",
	HandlerType: (*UserRoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "insertUserRole",
			Handler:    _UserRole_InsertUserRole_Handler,
		},
		{
			MethodName: "updateUserRole",
			Handler:    _UserRole_UpdateUserRole_Handler,
		},
		{
			MethodName: "removeUserRole",
			Handler:    _UserRole_RemoveUserRole_Handler,
		},
		{
			MethodName: "getUserRoles",
			Handler:    _UserRole_GetUserRoles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "admin.proto",
}
